<!DOCTYPE html>
<html lang="en">
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WZHW34FRXN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-WZHW34FRXN');
</script>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tile Burst</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body {
    font-family:'JetBrains Mono', monospace;
    background:#000;
    color:#00ff00;
    min-height:100dvh;
    overflow-x:hidden;
    overflow-y:auto;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
}

#tile-canvas {
    position:fixed;
    top:0; left:0;
    width:100%; height:100%;
    z-index:1;
    pointer-events:none;
    opacity:0.25;
}

.crt-effect {
    position:fixed; top:0; left:0; width:100%; height:100%;
    pointer-events:none; z-index:9999;
    background:linear-gradient(rgba(18,16,16,0) 50%, rgba(0,0,0,.25) 50%);
    background-size:100% 4px;
    animation:crt-flicker .15s infinite;
}
@keyframes crt-flicker { 0%,100%{opacity:.97} 50%{opacity:1} }

.back-btn {
    position:fixed;
    top:2rem; left:2rem;
    z-index:10;
    color:#00ff00;
    text-decoration:none;
    font-size:0.85rem;
    padding:0.5rem 1rem;
    border:1px solid #00ff00;
    border-radius:4px;
    background:rgba(0,0,0,0.5);
    transition:all 0.3s;
    letter-spacing:1px;
    font-family:'JetBrains Mono', monospace;
}
.back-btn:hover {
    background:rgba(0,255,0,0.1);
    box-shadow:0 0 15px #00ff00;
}

.content {
    position:relative;
    z-index:10;
    text-align:center;
    width:min(100%, 1080px);
    padding:clamp(1.1rem, 4vw, 2.6rem);
}

.app-title {
    font-size:clamp(2.1rem, 7.5vw, 3.9rem);
    font-weight:700;
    color:#00ff00;
    text-shadow:0 0 20px #00ff00, 0 0 40px #00ff00;
    letter-spacing:clamp(4px, 1.2vw, 8px);
    margin-bottom:clamp(0.5rem, 1.8vw, 0.9rem);
}

.app-subtitle {
    font-size:0.85rem;
    color:#00ff00;
    opacity:0.65;
    letter-spacing:4px;
    margin-bottom:3rem;
}

.store-row {
    display:flex;
    align-items:stretch;
    justify-content:center;
    flex-wrap:wrap;
    gap:clamp(1rem, 3vw, 2.8rem);
    width:min(100%, 980px);
}

.store-wrapper {
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:0.8rem;
    flex:1 1 320px;
    max-width:420px;
}

.store-btn {
    display:flex;
    align-items:center;
    width:100%;
    gap:clamp(1rem, 2vw, 1.9rem);
    padding:clamp(1.2rem, 2.4vw, 2rem) clamp(1.6rem, 3.4vw, 3.4rem);
    border:1px solid #00ff00;
    border-radius:14px;
    background:rgba(0,0,0,0.75);
    text-decoration:none;
    color:#00ff00;
    transition:all 0.3s;
    min-width:0;
    box-shadow:0 0 8px rgba(0,255,0,0.15);
}
.store-btn:hover {
    background:rgba(0,255,0,0.08);
    box-shadow:0 0 28px rgba(0,255,0,0.55);
    transform:scale(1.05);
}

.store-icon { flex-shrink:0; }
.store-icon svg {
    width:clamp(42px, 5vw, 58px);
    height:clamp(42px, 5vw, 58px);
}

.store-text .store-label {
    font-size:clamp(0.72rem, 1.5vw, 0.9rem);
    opacity:0.65;
    letter-spacing:2px;
    text-transform:uppercase;
}
.store-text .store-name {
    font-size:clamp(1.24rem, 3.1vw, 1.75rem);
    font-weight:700;
    letter-spacing:2.6px;
    text-shadow:0 0 6px #00ff00;
}

.coming-soon-tag {
    font-size:clamp(0.62rem, 1.2vw, 0.72rem);
    color:#00ff00;
    opacity:0.55;
    letter-spacing:clamp(2px, 0.6vw, 3.5px);
    border:1px solid rgba(0,255,0,0.25);
    padding:0.24rem clamp(0.55rem, 1.5vw, 0.76rem);
    border-radius:3px;
    text-shadow:0 0 4px #00ff00;
}

.footer {
    position:fixed;
    bottom:0.5rem; left:2rem;
    z-index:10;
    color:#00ff00;
    font-size:0.7rem;
    opacity:0.7;
    letter-spacing:1px;
}

@media (max-width: 900px) {
    .store-row {
        flex-direction:column;
        align-items:center;
        gap:1.2rem;
    }
    .store-wrapper {
        width:min(92vw, 420px);
        max-width:none;
        flex:0 1 auto;
    }
}

@media (max-width: 500px) {
    .content { padding:1rem; }
    .back-btn {
        top:1rem;
        left:1rem;
        font-size:0.75rem;
    }
    .footer {
        left:1rem;
        font-size:0.62rem;
    }
}
</style>
</head>
<body>

<canvas id="tile-canvas"></canvas>
<div class="crt-effect"></div>

<a href="../" class="back-btn">â† BACK</a>
<div class="footer">Â© 2026 Ishan Kumar Anand All Rights Reserved.</div>

<div class="content">
    <div class="app-title">TILE BURST</div>
    <!-- <div class="app-subtitle">PUZZLE GAME</div> -->

    <div class="store-row">

        <!-- App Store -->
        <div class="store-wrapper">
            <a href="https://apps.apple.com/us/app/tile-burst/id6759202744"
               target="_blank" class="store-btn">
                <div class="store-icon">
                    <svg width="44" height="44" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M18.71 19.5c-.83 1.24-1.71 2.45-3.05 2.47-1.34.03-1.77-.79-3.29-.79-1.53 0-2 .77-3.27.82-1.31.05-2.3-1.32-3.14-2.53C4.25 17 2.94 12.45 4.7 9.39c.87-1.52 2.43-2.48 4.12-2.51 1.28-.02 2.5.87 3.29.87.78 0 2.26-1.07 3.8-.91.65.03 2.47.26 3.64 1.98-.09.06-2.17 1.28-2.15 3.81.03 3.02 2.65 4.03 2.68 4.04-.03.07-.42 1.44-1.38 2.83M13 3.5c.73-.83 1.94-1.46 2.94-1.5.13 1.17-.34 2.35-1.04 3.19-.69.85-1.83 1.51-2.95 1.42-.15-1.15.41-2.35 1.05-3.11z"/>
                    </svg>
                </div>
                <div class="store-text">
                    <div class="store-label">Download on the</div>
                    <div class="store-name">APP STORE</div>
                </div>
            </a>
        </div>

        <!-- Play Store -->
        <div class="store-wrapper">
            <a href="https://apps.apple.com/us/app/tile-burst/id6759202744"
               target="_blank" class="store-btn">
                <div class="store-icon">
                    <svg width="44" height="44" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M3.18 23.76c.3.17.66.19.99.07l13.15-7.59-2.89-2.89-11.25 10.41zM.94 1.5C.36 1.83 0 2.43 0 3.12v17.77c0 .69.36 1.29.94 1.62l.1.06 9.95-9.95v-.23L1.03 1.44l-.09.06zM21.96 10.39l-2.83-1.64-3.17 3.17 3.17 3.16 2.85-1.64c.81-.47.81-1.58-.02-2.05zM3.18.24L16.33 7.83l-2.89 2.89L2.19.31c.33-.13.69-.1.99.07v-.14z"/>
                    </svg>
                </div>
                <div class="store-text">
                    <div class="store-label">Get it on</div>
                    <div class="store-name">GOOGLE PLAY</div>
                </div>
            </a>
            <div class="coming-soon-tag">COMING SOON</div>
        </div>

    </div>
</div>

<script>
const tc  = document.getElementById('tile-canvas');
const ctx = tc.getContext('2d');
const TILE = 52;
const MAX_SWEEPERS = 6;

let sweepers  = [];
let particles = [];

function cols() { return Math.ceil(tc.width  / TILE); }
function rows() { return Math.ceil(tc.height / TILE); }

function resize() { tc.width = window.innerWidth; tc.height = window.innerHeight; }
resize();
window.addEventListener('resize', resize);

// â”€â”€ Spawn a new row/col sweeper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function trySpawn() {
    const active = sweepers.filter(s => s.state !== 'done');
    if (active.length >= MAX_SWEEPERS) return;

    const C = cols(), R = rows();
    const horiz = Math.random() > 0.45;

    if (horiz) {
        const used = new Set(active.filter(s => s.horiz).map(s => s.idx));
        const avail = Array.from({length: R}, (_, i) => i).filter(i => !used.has(i));
        if (!avail.length) return;
        const idx = avail[Math.floor(Math.random() * avail.length)];
        const dir = Math.random() > 0.5 ? 1 : -1;
        sweepers.push({
            horiz: true, idx, dir, total: C,
            head:  dir > 0 ? -1 : C,
            placed: new Set(),
            speed: 0.13 + Math.random() * 0.1,
            op:    0.28 + Math.random() * 0.2,
            state: 'sweep', flashTimer: 0
        });
    } else {
        const used = new Set(active.filter(s => !s.horiz).map(s => s.idx));
        const avail = Array.from({length: C}, (_, i) => i).filter(i => !used.has(i));
        if (!avail.length) return;
        const idx = avail[Math.floor(Math.random() * avail.length)];
        const dir = Math.random() > 0.5 ? 1 : -1;
        sweepers.push({
            horiz: false, idx, dir, total: R,
            head:  dir > 0 ? -1 : R,
            placed: new Set(),
            speed: 0.13 + Math.random() * 0.1,
            op:    0.28 + Math.random() * 0.2,
            state: 'sweep', flashTimer: 0
        });
    }
}
setInterval(trySpawn, 380);

// â”€â”€ Burst particles from tile centre â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spray(cx, cy) {
    for (let i = 0; i < 10; i++) {
        const angle = Math.random() * Math.PI * 2;
        const spd   = 1.8 + Math.random() * 5;
        particles.push({
            x: cx, y: cy,
            vx: Math.cos(angle) * spd,
            vy: Math.sin(angle) * spd,
            life: 1.0,
            decay: 0.014 + Math.random() * 0.02,
            size:  1.5 + Math.random() * 4,
            square: Math.random() > 0.4
        });
    }
}

// â”€â”€ Main draw loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function draw() {
    requestAnimationFrame(draw);
    ctx.clearRect(0, 0, tc.width, tc.height);
    ctx.shadowBlur = 0;

    const C = cols(), R = rows();

    // Static faint grid
    ctx.lineWidth = 1;
    for (let r = 0; r < R; r++) {
        for (let c = 0; c < C; c++) {
            ctx.strokeStyle = 'rgba(0,255,0,0.07)';
            ctx.strokeRect(c * TILE + 0.5, r * TILE + 0.5, TILE - 1, TILE - 1);
        }
    }

    // Sweepers
    sweepers = sweepers.filter(s => {

        if (s.state === 'sweep') {
            s.head += s.dir * s.speed;
            const hf = Math.floor(s.head);

            // Mark tiles the head has passed through
            for (let i = 0; i < s.total; i++) {
                if (s.dir > 0 ? i <= hf : i >= hf) s.placed.add(i);
            }

            // Draw trail (placed tiles behind the head)
            ctx.shadowBlur = 0;
            for (const i of s.placed) {
                if (i === hf) continue; // head drawn separately
                const tx = s.horiz ? i * TILE : s.idx * TILE;
                const ty = s.horiz ? s.idx * TILE : i * TILE;
                ctx.fillStyle   = `rgba(0,255,0,${s.op * 0.3})`;
                ctx.strokeStyle = `rgba(0,255,0,${s.op})`;
                ctx.lineWidth   = 1;
                ctx.fillRect  (tx + 1,   ty + 1,   TILE - 2, TILE - 2);
                ctx.strokeRect(tx + 0.5, ty + 0.5, TILE - 1, TILE - 1);
            }

            // Draw glowing moving head (smooth fractional position)
            if (s.head >= 0 && s.head < s.total) {
                const hx = s.horiz ? s.head * TILE : s.idx * TILE;
                const hy = s.horiz ? s.idx * TILE   : s.head * TILE;
                const ho = Math.min(s.op * 2.5, 1.0);
                ctx.shadowBlur  = 20;
                ctx.shadowColor = 'rgba(0,255,0,0.95)';
                ctx.fillStyle   = `rgba(0,255,0,${ho * 0.55})`;
                ctx.strokeStyle = `rgba(0,255,0,${ho})`;
                ctx.lineWidth   = 2;
                ctx.fillRect  (hx + 1,   hy + 1,   TILE - 2, TILE - 2);
                ctx.strokeRect(hx + 0.5, hy + 0.5, TILE - 1, TILE - 1);
                ctx.shadowBlur = 0;
            }

            // Full-row/col check
            const exited = s.dir > 0 ? s.head >= s.total : s.head < 0;
            if (exited && s.placed.size >= s.total) {
                s.state = 'flash';
                s.flashTimer = 22;
            }

        } else if (s.state === 'flash') {
            // Pulsing bright flash before burst
            const pulse = 0.5 + Math.abs(Math.sin(s.flashTimer * 0.45)) * 0.5;
            ctx.shadowBlur  = 14;
            ctx.shadowColor = 'rgba(0,255,0,0.9)';
            for (let i = 0; i < s.total; i++) {
                const tx = s.horiz ? i * TILE : s.idx * TILE;
                const ty = s.horiz ? s.idx * TILE : i * TILE;
                ctx.fillStyle   = `rgba(0,255,0,${pulse * 0.5})`;
                ctx.strokeStyle = `rgba(0,255,0,${pulse})`;
                ctx.lineWidth   = 1.5;
                ctx.fillRect  (tx + 1,   ty + 1,   TILE - 2, TILE - 2);
                ctx.strokeRect(tx + 0.5, ty + 0.5, TILE - 1, TILE - 1);
            }
            ctx.shadowBlur = 0;

            s.flashTimer--;
            if (s.flashTimer <= 0) {
                // ğŸ’¥ BURST â€” spray particles from every tile in the row/col
                for (let i = 0; i < s.total; i++) {
                    const cx = (s.horiz ? i * TILE : s.idx * TILE) + TILE / 2;
                    const cy = (s.horiz ? s.idx * TILE : i * TILE) + TILE / 2;
                    spray(cx, cy);
                }
                return false; // remove sweeper
            }
        }

        return true;
    });

    // Particles
    particles = particles.filter(p => {
        p.x  += p.vx;
        p.y  += p.vy;
        p.vy += 0.055;   // gravity
        p.vx *= 0.975;   // drag
        p.life -= p.decay;
        if (p.life <= 0) return false;

        const sz = Math.max(0.5, p.size * p.life);
        ctx.fillStyle = `rgba(0,255,0,${p.life * 0.9})`;
        if (p.square) {
            ctx.fillRect(p.x - sz / 2, p.y - sz / 2, sz, sz);
        } else {
            ctx.beginPath();
            ctx.arc(p.x, p.y, sz / 2, 0, Math.PI * 2);
            ctx.fill();
        }
        return true;
    });
}
draw();
</script>
</body>
</html>
